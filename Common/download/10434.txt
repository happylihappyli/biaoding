using Newtonsoft.Json.Linq;
using Common_Robot2;
using ConverxHull;
using pcammls;
using OuelletConvexHull;

namespace Test1
{
    /// <summary>
    /// 这个是每个角度，每一行都带一个多边形框
    /// </summary>
    public class C_Cloud_Split_By_Region : C_Node
    {
        public string key_cloud = "#cloud1";
        public string? key_cloud_arm = "";

        public string key_save = "#cloud_array";
        public string key_main = "mains";//List<C_Main>
        public string key_camera = "&#1";
        public string key_bottom = "#pPlanet_Bottom1";
        public string key_jarray = "";
        public string key_image = "";
        public string key_region = "#点云过滤区";

        public string angle = "@#全局角度";
        public string angle_start="-10";
        public string row = "@#行计数器";


        public List<C_Point3D>? edge_points = null;
        public JArray? JArray_Box = null;
        public string no_cover = "1";//覆盖的不抓取
        public string contour = "1";
        public string file_polygon = "";

        public double draw_scale_tuyang = 1;
        public string draw_scale = "0.5";
        public string scale = "2";

        public string? dir="";

        public C_Cloud_Split_By_Region(string name, C_Space space_parent, C_Space space) :
            base(name, space_parent, space)
        {
        }

        public override Task run_sub()
        {
            this.draw_scale_tuyang = double.Parse(this.draw_scale);
            run_sub_main();
            return Task.CompletedTask;
        }

        private void run_sub_main()
        {
            点云分块(pTrain);
        }


        public C_Rect? 计算分割框的矩形(JObject pItem)
        {
            JArray? pJArray;
            if (contour == "1")
            {
                pJArray = (JArray?)pItem.SelectToken("contour");
            }
            else
            {
                pJArray = (JArray?)pItem.SelectToken("vertex");
            }
            if (pJArray == null)
            {
                return null;
            }

            int x_min = 10000;
            int x_max = -10000;
            int y_min = 10000;
            int y_max = -10000;

            for (var j = 0; j < pJArray.Count; j++)
            {
                int x1 = (int)pJArray[j][0];
                int y1 = (int)pJArray[j][1];

                x1 = (int)Math.Round(x1 / this.draw_scale_tuyang + space.vars.draw_offset_x_tuyang);
                y1 = (int)Math.Round(y1 / this.draw_scale_tuyang + space.vars.draw_offset_y_tuyang);

                if (x1 > x_max) x_max = x1;
                if (x1 < x_min) x_min = x1;
                if (y1 > y_max) y_max = y1;
                if (y1 < y_min) y_min = y1;
            }

            return new C_Rect(new C_Point3D(x_min, y_min, 0), new C_Point3D(x_max, y_max, 0));
        }


        public C_Rect? 计算原始的分割框的矩形(JObject pItem)
        {
            JArray? pJArray;
            if (contour == "1")
            {
                pJArray = (JArray?)pItem.SelectToken("contour");
            }
            else
            {
                pJArray = (JArray?)pItem.SelectToken("vertex");
            }
            if (pJArray == null) return null;

            int x_min = 10000;
            int x_max = -10000;
            int y_min = 10000;
            int y_max = -10000;

            for (var j = 0; j < pJArray.Count; j++)
            {
                int x1 = (int)(int)(pJArray[j][0]);
                int y1 = (int)(int)(pJArray[j][1]);

                if (x1 > x_max) x_max = x1;
                if (x1 < x_min) x_min = x1;
                if (y1 > y_max) y_max = y1;
                if (y1 < y_min) y_min = y1;
            }

            return new C_Rect(new C_Point3D(x_min, y_min, 0), new C_Point3D(x_max, y_max, 0));
        }



        //这个函数可能有问题
        public C_Point3D depth_to_3DPoint3(TY_CAMERA_CALIB_INFO src_calib, C_Point3D pPoint)
        {
            //相机内参
            double cam_cx = src_calib.intrinsic.data[2];// 6.52000427e+02;// * 640 / 1280;
            double cam_cy = src_calib.intrinsic.data[5];//5.06252594e+02;// * 480 / 960;
            double cam_fx = src_calib.intrinsic.data[0];// 1.09007092e+03;
            double cam_fy = src_calib.intrinsic.data[4];//1.09046729e+03;
            double factor = 1;

            double p_z = pPoint.z / factor;
            double p_x = (pPoint.x - cam_cx) * p_z / cam_fx;
            double p_y = (pPoint.y - cam_cy) * p_z / cam_fy;
            return new C_Point3D(p_x, p_y, p_z);
        }


        public void 点云分块(I_Train? pTrain)
        {


            List<C_Point3D>? list_3d_point_camera = (List<C_Point3D>?)this.read_var(key_cloud, "List<C_Point3D>");
            if (list_3d_point_camera == null)
            {
                S_TTS.speak_async(this.Name + " 摄像头点云为空！");
                return;
            }



            List<C_Point3D>? list_3D_Point_arm = (List<C_Point3D>?)this.read_var(key_cloud_arm, "List<C_Point3D>");
            if (list_3D_Point_arm == null)
            {
                S_TTS.speak_async(this.Name + " 机械臂点云为空！");
                return;
            }



            C_Camera_TuYang? camera1 = (C_Camera_TuYang?)this.read_var(this.key_camera, "C_Camera_TuYang");

            if (camera1 == null)
            {
                MessageBox.Show(this.Name + ",camera1=null");
                return;
            }

            this.JArray_Box = (JArray?)this.read_var(this.key_jarray, "JArray");
            if (this.JArray_Box == null)
            {
                MessageBox.Show(this.Name + " JArray ==null key_jarray 可能设置有问题");
                return;
            }


            string? str_file_polygon= this.read_string(this.file_polygon);
            if (str_file_polygon == null)
            {
                S_TTS.speak_async("没有过滤区文件名！");
                return;
            }

            string? strDir = this.read_string(this.dir);
            string str_angle = this.read_string(this.angle);
            if (str_angle == "")
            {
                S_TTS.speak_async(this.Name + " 角度 错误");
                return;
            }
            int i_angle = int.Parse(str_angle);

            string str_row = this.read_string(this.row);
            if (str_row == "")
            {
                S_TTS.speak_async(this.Name + " 行计数器 错误");
                return;
            }
            int i_row = int.Parse(str_row);

            str_file_polygon = str_file_polygon.Replace("{fold}", strDir + "");
            str_file_polygon = str_file_polygon.Replace("{angle}", i_angle + "");
            str_file_polygon = str_file_polygon.Replace("{row}", i_row + "");


            List<C_Point3D>? list_edge = null;
            if (File.Exists(str_file_polygon))
            {
                Main.WriteLine(this,"过滤框："+str_file_polygon);
                list_edge = Main.cloud_read(this,str_file_polygon, ",");
                this.save_var(this.key_region, "List<C_Point3D>", list_edge);
            }
            else
            {
                File.WriteAllText(str_file_polygon, "");
            }


            Bitmap? pBitmap1 = (Bitmap?)this.read_var(this.key_image, "Bitmap");

            List<C_Data> list_c_data = new List<C_Data>();
            this.save_var(this.key_main, "List<C_Data>", list_c_data);

            for (var i = 0; i < this.JArray_Box.Count; i++)
            {
                JObject? pItem = (JObject)this.JArray_Box[i];

                string label = pItem==null?"":pItem["label"].ToString();


                C_Data pData = new C_Data(space);
                pData.Group_ID = i;
                pData.bCover = true;
                pData.Label = label;

                if (label.IndexOf("_intact") > -1)
                {
                    pData.bCover = false;
                }

                bool bWork = false;
                if (this.no_cover == "1")
                {
                    if (pData.bCover == false)
                    {
                        bWork = true;
                    }
                }
                else
                {
                    bWork = true;
                }

                if (bWork)
                {
                    pData.JObject = pItem;
                    pData.pRect = 计算分割框的矩形(pItem);
                    pData.pRect_No_Move = 计算原始的分割框的矩形(pItem);//不缩放，不移动

                    if (pData.pRect == null)
                    {
                        S_TTS.speak_async("有错误！");
                        Main.WriteLine("error");
                        return;
                    }

                    double x = (pData.pRect.pPoint1.x + pData.pRect.pPoint2.x) / 2;
                    double y = (pData.pRect.pPoint1.y + pData.pRect.pPoint2.y) / 2;



					//计算重心是否在多边形内部
                    if (list_edge==null || list_edge.Count<3 || Main.判断是否在多边形内(list_edge,x,y)) 
                    {
                        if (pData.pRect.width() > 20 && pData.pRect.height() > 20)
                        {
                            pData.pBmp = new Bitmap(pData.pRect_No_Move.width(), pData.pRect_No_Move.height());

                            Graphics g = Graphics.FromImage(pData.pBmp);

                            if (pBitmap1 != null)
                            {
                                lock (pBitmap1)
                                {
                                    int width = (int)(pBitmap1.Width * space.vars.draw_scale_tuyang); //先缩小
                                    int height = (int)(pBitmap1.Height * space.vars.draw_scale_tuyang);
                                    Bitmap pBitmap_Tmp = new Bitmap(pBitmap1, width, height);

                                    lock (pBitmap_Tmp)  //复制区域图片
                                    {
                                        g.DrawImage(pBitmap_Tmp,
                                        new Rectangle(0, 0, pData.pRect_No_Move.width(), pData.pRect_No_Move.height()),
                                        new Rectangle((int)pData.pRect_No_Move.pPoint1.x, (int)pData.pRect_No_Move.pPoint1.y,
                                            pData.pRect_No_Move.width(), pData.pRect_No_Move.height()),
                                        GraphicsUnit.Pixel);
                                    }
                                }
                            }
                            list_c_data.Add(pData);
                        }
                        else
                        {
                            Main.WriteLine(this.Name + ": 矩形太小了！");
                        }
                    }
                    else
                    {
                        //Main.WriteLine(this.Name + " G=" + pData.Group_ID + " 不在多边形过滤框内！");
                    }

                }
            }

            this.save_var(this.key_main + "/count", "double", list_c_data.Count);
            if (list_c_data.Count == 0)
            {
                Main.WriteLine(this.Name + ": arrMain.Count=0");
                S_TTS.speak_async(this.Name + " 点云分块为空！");
                this.Next_Step = Node_Next.False;
                return;
            }

            C_Data.tasks = new Task[list_c_data.Count];




            if (list_3d_point_camera == null)
            {
                MessageBox.Show(this.Name + "：" + key_cloud + "== null!");
                this.Next_Step = Node_Next.False;
                S_TTS.speak_async("点云分块为空！");
                return;
            }
            else
            {
                this.save_var(this.key_cloud_arm,"List<C_Point3D>", list_3D_Point_arm);
            }
            bool bDebug = false;// true;

            float db_Scale = float.Parse(this.scale);// 2f;//缩放比
            List<C_Point3D> list_uv = new List<C_Point3D>();
            if (bDebug)
            {
                List<C_Point3D> pList3 = new List<C_Point3D>();

                for (int i = 0; i < list_3d_point_camera.Count; i++)
                {
                    C_Point3D p = list_3d_point_camera[i];
                    if (p.z < 2155)
                    {
                        C_Point3D uv = Tools.f_3DPoint_to_depth(camera1.camera1.color_calib, p);
                        if (uv == null) continue;
                        uv.x = uv.x / db_Scale;
                        uv.y = uv.y / db_Scale;
                        list_uv.Add(uv);
                        pList3.Add(p);
                    }
                }


                Bitmap bmp_new = new Bitmap(pBitmap1.Width, pBitmap1.Height);
                Graphics g2 = Graphics.FromImage(bmp_new);

                g2.DrawImage(pBitmap1,
                            new Rectangle(0, 0, pBitmap1.Width, pBitmap1.Height),
                            new Rectangle(0, 0, pBitmap1.Width, pBitmap1.Height),
                            GraphicsUnit.Pixel);

                for (int i = 0; i < list_uv.Count; i++)
                {
                    C_Point3D uv = list_uv[i];
                    {
                        g2.DrawEllipse(Pens.Red, uv.x, uv.y, 5, 5);
                    }
                }
            }
            else
            {
                for (int i = 0; i < list_3d_point_camera.Count; i++)
                {
                    C_Point3D p = list_3d_point_camera[i];
                    {
                        C_Point3D uv = Tools.f_3DPoint_to_depth(camera1.camera1.color_calib, p);
                        if (uv == null) continue;
                        uv.x = uv.x / db_Scale;
                        uv.y = uv.y / db_Scale;
                        list_uv.Add(uv);
                    }
                }

            }

            for (var i = list_c_data.Count - 1; i >= 0; i--)
            {
                C_Data pData = list_c_data[i];
                if (pData.bCover && this.no_cover == "1")
                {
                    list_c_data.Remove(pData);
                    continue;
                }

                JArray? pJArray = (JArray?)pData.JObject.SelectToken("vertex");

                if (pJArray == null)
                {
                    pJArray = (JArray?)pData.JObject.SelectToken("contour");
                    if (pJArray == null)
                    {
                        MessageBox.Show("轮廓线为空！");
                        return;
                    }
                }
                edge_points = 简化边框读为凸多边形(pJArray);
                C_Point3D center= Main.计算中心点坐标(edge_points);//center是2D图像的中心点

                //int rnd_x = 0;
                //int rnd_y = 0;
                //Random rnd = new Random();
                //int count = 0;
                //C_Point3D pPoint2;
                //bool bFilter = false;
                //while (true)
                //{
                //    pPoint2 = Main.图像转3D点云(this.glb_p3dArray, pBitmap1.Width, (int)center.x+rnd_x, (int)center.y + rnd_y);
                //    if (double.IsNaN(pPoint2.x) == false)
                //    {
                //        break;
                //    }
                //    rnd_x = rnd.Next(20) - 10;
                //    rnd_y = rnd.Next(20) - 10;
                //    count++;
                //    if (count > 30)
                //    {
                //        Main.WriteLine(this, ">>>>>>>>>>>>>>>>>>>>>>>>>>中间点云缺失！");
                //        bFilter = true;
                //        break;
                //    }
                //}

                //if (bFilter == false)
                {
                    (pData.list_3D_Point,pData.list_3D_Point_arm) = 根据深度神经网络识别框2过滤点云(
                        pData, list_3d_point_camera, list_3D_Point_arm, list_uv, pData.Group_ID,pData.JObject);

                    if (pData.list_3D_Point == null || pData.list_3D_Point.Count < 3)
                    {
                        list_c_data.Remove(pData);
                        continue;
                    }
                    pData.run_pre();
                }
                //else
                //{
                //    Main.WriteLine(this.Name + " 点云分块2 " + i + " 被过滤掉");
                //}

            }
            this.save_var(this.key_main + "/count", "double", list_c_data.Count);


            Main.WriteLine(this.Name+ "点云分块 3");
            List<List<C_Point3D>> list = new List<List<C_Point3D>>();

            for (var i = 0; i < list_c_data.Count; i++)
            {
                C_Data item = list_c_data[i];
                if (item.list_3D_Point!=null)
                {
                    list.Add(item.list_3D_Point);
                }
            }
            this.save_var(this.key_save, "List<List<C_Point3D>>", list);
            Main.WriteLine(this.Name+"点云分块 结束");

            this.Next_Step = Node_Next.True;
        }


        public List<C_Point3D> 简化边框读为凸多边形(
            JArray pJArray,
            bool bModify = true)
        {
            List<C_Point3D> pList_Points = new List<C_Point3D>();

            for (var j = 0; j < pJArray.Count; j++)
            {
                int x1 = (int)pJArray[j][0];
                int y1 = (int)pJArray[j][1];

                if (bModify)
                {
                    x1 = (int)Math.Round(x1 / this.draw_scale_tuyang);// + space.vars.draw_offset_x_tuyang);
                    y1 = (int)Math.Round(y1 / this.draw_scale_tuyang);// + space.vars.draw_offset_y_tuyang);
                }
                C_Point3D pPoint = new C_Point3D(x1, y1, 0);
                pList_Points.Add(pPoint);
            }

            return Main.计算外接多边形(pList_Points);
        }


        //先转化为矩形
        public (List<C_Point3D>? list_camera,List<C_Point3D>? list_arm)
            根据深度神经网络识别框2过滤点云(
            C_Data pData,
            List<C_Point3D> list_point_camera,
            List<C_Point3D> list_point_arm,
            List<C_Point3D> list_uv,
            int Group_ID,JObject pItem)
        {

            //Main.WriteLine(this,"GID="+pData.Group_ID);

            JArray? pJArray = (JArray?)pItem.SelectToken("vertex");

            if (pJArray == null)
            {
                pJArray = (JArray?)pItem.SelectToken("contour");
                if (pJArray == null)
                {
                    return (null,null);
                }
            }

            edge_points = 简化边框读为凸多边形(pJArray);
            pData.edge_points = edge_points;

            return Main.check_in_out(Group_ID, edge_points, list_point_camera, list_point_arm, list_uv);
        }

        private List<C_Point3D> check_in_out_zzz(int Group_ID, 
            List<C_Point3D> edges, List<C_Point3D> points_all, List<C_Point3D> list_uv)
        {
            List<C_Point3D> pList = new List<C_Point3D>();
            try
            {


                int count_sample = list_uv.Count;
                float[] arrX = new float[count_sample];
                float[] arrY = new float[count_sample];
                float[] arrAngle = new float[count_sample];

                for (int i = 0; i < count_sample; i++)
                {
                    C_Point3D uv = list_uv[i];   //C_Point3D uv = Tools.f_3DPoint_to_depth(camera1.color_calib, p);
                    if (uv != null)
                    {
                        //arrX[i] = uv.x;
                        //arrY[i] = uv.y;
                        if (Main.判断是否在多边形内(edges, uv.x, uv.y))
                        {
                            pList.Add(points_all[i]);
                        }
                    }
                }




                // 打印结果
                //Console.WriteLine("--------------X-------------");
                //for (int i = 0; i < count_sample; i++)
                //{
                //    float z = list_uv[i].z;
                //    float angle_z = arrAngle[i];

                //    if (Math.Abs(angle_z) > 1)
                //    {
                //        points_all[i].Group_ID = Group_ID;
                //        pList.Add(points_all[i]);
                //    }
                //}


            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
            return pList;
        }


        public List<C_Point3D> 简化边框读为矩形(
            JArray pJArray,
            bool bModify = true)
        {
            List<C_Point3D> pList_Points = new List<C_Point3D>();

            for (var j = 0; j < pJArray.Count; j++)
            {
                int x1 = (int)pJArray[j][0];
                int y1 = (int)pJArray[j][1];

                if (bModify)
                {
                    x1 = (int)Math.Round(x1 / this.draw_scale_tuyang);// + space.vars.draw_offset_x_tuyang);
                    y1 = (int)Math.Round(y1 / this.draw_scale_tuyang);// + space.vars.draw_offset_y_tuyang);
                }
                C_Point3D pPoint = new C_Point3D(x1, y1, 0);
                pList_Points.Add(pPoint);
            }

            RotatedRect rect = 计算外接矩形(pList_Points);

            C_Point3D[] ps = rect.Points();

            List<C_Point3D> pList_Points2 = new List<C_Point3D>();
            for (int i = 0; i < ps.Length; i++)
            {
                pList_Points2.Add(ps[i]);
            }

            return pList_Points2;
        }


        public RotatedRect 计算外接矩形(List<C_Point3D> pList)
        {


            Bitmap bmp = new Bitmap(1200, 900);
            Graphics e = Graphics.FromImage(bmp);
            int n = pList.Count;
            C_Point3D[] points = new C_Point3D[n];
            for (int j = 0; j < n; j++)
            {

                C_Point3D p = pList[j];

                C_Point3D p2 = p;//.add(new C_Point3D(500,300,0));//Tools.f_3DPoint_to_depth(camera1.color_calib, p.add(centerAll));
                points[j] = p2;

                e.DrawEllipse(Pens.Red, p2.x, p2.y, 10, 10);
            }

            var windowsPoints = points.Select(p => new ConverxHull.Point(p.x, p.y)).ToList();

            var ouelletConvexHull = new ConvexHull(windowsPoints);
            ouelletConvexHull.CalcConvexHull(ConvexHullThreadUsage.OnlyOne);

            List<C_Point3D> ouelletAsVertices = ouelletConvexHull.GetResultsAsArrayOfPoint()
                .Select(p => new C_Point3D(p.X, p.Y, 0)).ToList();

            Polygon currentPolygon = new Polygon();
            for (var i = 0; i < ouelletAsVertices.Count - 1; i++)
            {
                var p1 = ouelletAsVertices[i];
                var p2 = ouelletAsVertices[i + 1];
                e.DrawLine(new Pen(Color.Yellow), (float)p1.x, (float)p1.y, (float)p2.x, (float)p2.y);
                currentPolygon.AddPoint(new System.Drawing.Point((int)p1.x, (int)p1.y));
            }
            currentPolygon.CompletePolygon = true;


            double min_angle = 计算最小外接矩形(ouelletAsVertices);


            List<C_Point3D> currentPolygon2 = 旋转点云(min_angle, ouelletAsVertices);

            C_Planet pPlanet = 计算最大最小值(currentPolygon2);

            C_Point3D a = pPlanet.x0y0;
            C_Point3D b = new C_Point3D(pPlanet.x0y0.x, pPlanet.x1y1.y, 0);
            C_Point3D c = pPlanet.x1y1;
            C_Point3D d = new C_Point3D(pPlanet.x1y1.x, pPlanet.x0y0.y, 0);

            List<C_Point3D> result = new List<C_Point3D>();
            result.Add(a);
            result.Add(b);
            result.Add(c);
            result.Add(d);

            List<C_Point3D> result2 = 旋转点云(-min_angle, result);
            a = result2[0];
            b = result2[1];
            c = result2[2];
            d = result2[3];

            e.DrawLine(new Pen(Color.Blue, 3), (float)a.x, (float)a.y, (float)b.x, (float)b.y);
            e.DrawLine(new Pen(Color.Blue, 3), (float)c.x, (float)c.y, (float)b.x, (float)b.y);
            e.DrawLine(new Pen(Color.Blue, 3), (float)c.x, (float)c.y, (float)d.x, (float)d.y);
            e.DrawLine(new Pen(Color.Blue, 3), (float)a.x, (float)a.y, (float)d.x, (float)d.y);

            return new RotatedRect(a, b, c, d);

        }



        public double 计算最小外接矩形(List<C_Point3D> currentPolygon)
        {
            C_Point3D a = currentPolygon[0];
            C_Point3D b = currentPolygon[1];
            List<C_Point3D> currentPolygon2;

            double min_angle = Math.Atan2(b.y - a.y, b.x - a.x);
            currentPolygon2 = 旋转点云(min_angle, currentPolygon);
            double min_area = 计算最小外接正矩形面积(currentPolygon2);

            C_Point3D c, d;
            double angle2, min_area2;
            for (int i = 0; i < currentPolygon.Count - 1; i++)
            {
                c = currentPolygon[i];
                d = currentPolygon[i + 1];
                angle2 = Math.Atan2(d.y - c.y, d.x - c.x);
                currentPolygon2 = 旋转点云(angle2, currentPolygon);
                min_area2 = 计算最小外接正矩形面积(currentPolygon2);
                if (min_area2 < min_area)
                {
                    min_area = min_area2;
                    min_angle = angle2;
                }
            }
            c = currentPolygon[currentPolygon.Count - 1];
            d = currentPolygon[0];
            angle2 = Math.Atan2(d.y - c.y, d.x - c.x);
            currentPolygon2 = 旋转点云(angle2, currentPolygon);
            min_area2 = 计算最小外接正矩形面积(currentPolygon2);
            if (min_area2 < min_area)
            {
                min_area = min_area2;
                min_angle = angle2;
            }

            return min_angle;
        }



        public double 计算最小外接正矩形面积(List<C_Point3D> currentPolygon)
        {
            C_Planet pPlanet = 计算最大最小值(currentPolygon);

            return Math.Abs(pPlanet.x0y0.x - pPlanet.x1y1.x) * Math.Abs(pPlanet.x0y0.y - pPlanet.x1y1.y);
        }



        ////计算x，y，z最大，最小值
        public static C_Planet 计算最大最小值(List<C_Point3D> pList)
        {
            double x_min = 100000;
            double x_max = -100000;
            double y_min = 100000;
            double y_max = -100000;
            double z_min = 100000;
            double z_max = -100000;

            for (int i = 0; i < pList.Count; i++)
            {
                C_Point3D p = (C_Point3D)pList[i];
                if (p.x < x_min) x_min = p.x;
                if (p.y < y_min) y_min = p.y;
                if (p.z < z_min) z_min = p.z;

                if (p.x > x_max) x_max = p.x;
                if (p.y > y_max) y_max = p.y;
                if (p.z > z_max) z_max = p.z;
            }

            C_Planet pPlanet = new C_Planet(-1);

            pPlanet.x0y0 = new C_Point3D(x_min, y_min, z_min);
            pPlanet.x1y1 = new C_Point3D(x_max, y_max, z_max);

            return pPlanet;
        }



        public List<C_Point3D> 旋转点云(double angle, List<C_Point3D> currentPolygon)
        {
            List<C_Point3D> polygon2 = new List<C_Point3D>();

            for (int i = 0; i < currentPolygon.Count; i++)
            {
                C_Point3D a = currentPolygon[i];
                double angle2 = Math.Atan2(a.y, a.x);

                double distance = a.distance(new C_Point3D(0, 0, 0));
                if (distance > 0)
                {
                    double x = distance * Math.Cos(angle2 - angle);
                    double y = distance * Math.Sin(angle2 - angle);
                    C_Point3D b = new C_Point3D(x, y, 0);
                    polygon2.Add(b);
                }
                else
                {
                    polygon2.Add(a);
                }
            }
            return polygon2;
        }

        public List<C_Point3D> 简化边框读取边框里的点(
            JArray pJArray,
            bool bModify = true)
        {
            List<C_Point3D> pList_Points = new List<C_Point3D>();

            for (var j = 0; j < pJArray.Count; j++)
            {
                int x1 = (int)pJArray[j][0];
                int y1 = (int)pJArray[j][1];

                if (bModify)
                {
                    x1 = (int)Math.Round(x1 / space.vars.draw_scale_tuyang + space.vars.draw_offset_x_tuyang);
                    y1 = (int)Math.Round(y1 / space.vars.draw_scale_tuyang + space.vars.draw_offset_y_tuyang);
                }
                C_Point3D pPoint = new C_Point3D(x1, y1, 0);
                pList_Points.Add(pPoint);
            }


            return pList_Points;
        }

        public override void init()
        {
            
        }
    }
}
