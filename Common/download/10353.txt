using Common_Robot2;
using ConverxHull;
using System.Collections.Generic;
using System.Diagnostics;

namespace Test1
{


    public class Cal_Catch_Sucker_All : C_Node
    {
        public string key_save = "pPlanet_Top";
        public string max_ry = "70";
        public string key_array_main = "mains";
        public string key_last = "";//上次抓取的面

        public string debug = "1";
        public string use_last = "0";
        public string calculate_type = "x";
        public string z_min = "-1680";
        public string key_cloud_save = "";//抓取面所对应的箱子点云
        

        public List<C_Data> not_move;
        public C_Train pTrain_Old = null;
        public C_Train pTrain_Finished = null;

        public string key_save_len1 = "";
        public string key_save_len2 = "";
        public string key_robot = "";
        public string file = "";//机器人旋转轴文件
        public string angle_dif = "0";
        public string key_regions = "#吸盘分区1,#吸盘分区2,#吸盘分区3,#吸盘分区4";//吸盘变量
        public string y_min= "-870";
        public string sucker_y_span="193";
        public string key_planets;
        public string key_list_data = "";
        public string key_missing = "";//是否有遗漏的，保存变量

        public string y1_d1 = "-514.666538";// " - 193 * 2.666666";
        public string y1_d2 = "-193";
        public string key_sucker="";//吸盘变量
        public string key_camera="";//摄像头变量
        public string key_sucker_dxyz = "";
        public string min_cup_count = "";
        public string direction = "x";

        public Cal_Catch_Sucker_All(
            string name,
            C_Space space_parent,
            C_Space space) :
            base(space_parent, space)
        {
            this.Name = name;
            space.vars_step.Add(Name, this);
        }


        public override Task run_sub()
        {
            run_sub_main();
            return Task.CompletedTask;
        }


        public void run_sub_main()
        {
            string type =this.read_string(this.calculate_type);
            run_sub_main1(type);
        }



        private void run_sub_main1(string direction)
        {

            List<C_Data> list_data4 = (List<C_Data>)this.read_var(this.key_list_data, "List<C_Data>");

            C_Sucker sucker = (C_Sucker)this.read_var(this.key_sucker, "");

            int[] 吸盘分区 = new int[sucker.regions_count()];
            for(var i = 0; i < sucker.regions_count(); i++)
            {
                吸盘分区[i] = 0;
            }

            List<C_Data> list_data_catch = new List<C_Data>();//按照法向量过滤，默认一般是x方向
            //横过来找右边第二个，第三个箱子....
            for (var i = 0; i < list_data4.Count; i++)
            {
                C_Data pData_Catch = list_data4[i];//选择第一个
                if (pData_Catch.bFilter == false && pData_Catch.planet != null)
                {
                    list_data_catch.Add(pData_Catch);
                }
            }


            if (list_data_catch.Count==0)
            {
                this.remove_var(this.key_cloud_save, "List<C_Point3D>");
                S_TTS.speak_async(this.Name+ " No,No,No 方向：" + direction);
                Main.WriteLine(this, " No,No,No 方向：" + direction);
                this.Next_Step = Node_Next.False;
            }
            else
            {
                C_Data pData_Catch = list_data_catch[0];

                List<C_Planet_Catch> list_draw = new List<C_Planet_Catch>();//要抓取的3个（最多3个）
                List<C_Planet_Catch> list_draw2 = new List<C_Planet_Catch>();//条件更松一些，同一行的都放进来
                list_draw.Add(pData_Catch.planet);
                list_draw2.Add(pData_Catch.planet);

                for (var i =1; i < list_data_catch.Count; i++)
                {
                    C_Data pData_Catch2 = list_data_catch[i];//选择第2个
                    if (Math.Abs(pData_Catch.planet.arm_a.x - pData_Catch2.planet.arm_a.x)<50)
                    {
                        if (Math.Abs(pData_Catch.planet.arm_a.z - pData_Catch2.planet.arm_a.z) < 50)
                        {
                            double y1 = pData_Catch.planet.arm_a.y - pData_Catch.planet.dy;
                            double y2 = pData_Catch2.planet.arm_a.y - pData_Catch2.planet.dy;

                            double y1_d1 = double.Parse(this.y1_d1);
                            double y1_d2 = double.Parse(this.y1_d2);

                            if ( y1+ y1_d1 < y2  && y2< y1 +y1_d2) //按 y_d1,y_d2过滤了一个区间
                            {
                                list_draw.Add(pData_Catch2.planet);
                            }

                            list_draw2.Add(pData_Catch2.planet);//这一行的，
                        }
                    }
                }

                string str_y_min = this.read_string(this.y_min);
                double db_y_min = double.Parse(str_y_min);


                C_Point3D dxyz = (C_Point3D)this.read_var(this.key_sucker_dxyz, "");
                int min_cup_count =int.Parse(this.read_string(this.min_cup_count));


                sucker.dx = dxyz.x;
                sucker.dy = dxyz.y;
                sucker.dz = dxyz.z;

                C_Camera_TuYang camera1 = (C_Camera_TuYang)this.read_var(this.key_camera, "");

                if (pData_Catch.planet.arm_a.y > db_y_min) //如果是左边
                {
                    //默认是第一个分区对准第一个箱子的中心(这里用y，z坐标系，吸盘吸嘴的数据也要转为yz坐标系和机械臂一样)

                    float x = pData_Catch.planet.arm_a.x - pData_Catch.planet.dx;
                    float y = pData_Catch.planet.arm_a.y - pData_Catch.planet.dy;
                    float z = pData_Catch.planet.arm_a.z - pData_Catch.planet.dz;

                    sucker.set_first_region_center(x,y,z);

                    //判断在当前情况下，list_draw中的每个箱子有多少个吸嘴，如果大于 min_cup_count，则可以抓取这个箱子

                    List<List<C_Cup>> list_no_sucker = new List<List<C_Cup>>();//代表不吸取的箱子的数组下标
                    List<C_Cup> list_all = new List<C_Cup>();
                    for (var i = 0; i < list_draw.Count; i++)
                    {
                        C_Planet_Catch pCatch = list_draw[i];

                        List<C_Cup> list = Main.计算匹配的吸嘴数(list_all,camera1, sucker, pCatch,direction);

                        pCatch.list_cup=list;
                        if (list.Count >=min_cup_count)
                        {
                            pCatch.bSuck = true;
                        }
                        else
                        {
                            pCatch.bSuck = false;
                            list_no_sucker.Add(list);
                        }
                    }

                    Dictionary<string, string> dic_regions_sucker = get_regions_from_list(list_all);
                    Dictionary<string, string> dic_regions = get_regions_from_list_list(list_no_sucker);

                    foreach (KeyValuePair<string, string> kv in dic_regions_sucker)
                    {
                        int index = int.Parse(kv.Key);
                        吸盘分区[index] = 1;
                    }
                    foreach (KeyValuePair<string,string> kv in dic_regions)
                    {
                        int index=int.Parse(kv.Key);
                        吸盘分区[index] = 0;
                    }
                    bool bModify = true;
                    while (bModify)  //吸嘴关闭后会影响到其他要吸取的箱子，这些箱子都要重新计算一下，直到所有的吸嘴都不在变化
                    {
                        bModify=false;
                        dic_regions = get_regions_from_list_list(list_no_sucker);
                        for (var i = 0; i < list_draw.Count; i++)
                        {
                            C_Planet_Catch pCatch = list_draw[i];
                            if (pCatch.bSuck)
                            {
                                if (Main.计算启用的吸盘个数(pCatch.list_cup, dic_regions) < min_cup_count)
                                {
                                    pCatch.bSuck = false;
                                    list_no_sucker.Add(pCatch.list_cup);
                                    bModify = true;
                                }
                            }
                                
                        }
                        dic_regions = get_regions_from_list_list(list_no_sucker);
                        foreach (KeyValuePair<string, string> kv in dic_regions)
                        {
                            int index = int.Parse(kv.Key);
                            吸盘分区[index] = 0;
                        }
                    }

                    if (dic_regions.Count >= sucker.regions_count())
                    {
                        MessageBox.Show("吸盘会干涉！");
                    }
                }
                else
                {
                    Main.WriteLine("最右边，要撞右边墙！");
                }

                this.save_var(this.key_planets, "List<C_Planet_Catch>", list_draw);
                if (list_data_catch.Count>list_draw.Count)
                {
                    this.save_var(this.key_missing, "string", "1");
                }
                else
                {
                    this.save_var(this.key_missing, "string", "0");
                }

                C_Planet_Catch pCatch_planet = pData_Catch.planet;
                C_Robot pRobot = (C_Robot)this.read_var(this.key_robot, "C_Robot");
                C_Point3D A_new = pCatch_planet.arm_a;
                C_Point3D B_new;
                if (direction == "x")
                {
                    B_new = pCatch_planet.arm_a.add(new C_Point3D(-264, 0, 0));//AB=264     pCatch.arm_b;
                }
                else if (direction == "z")
                {
                    B_new = pCatch_planet.arm_a.add(new C_Point3D(0, 0, 264));//AB=264     pCatch.arm_b;
                }
                else
                {
                    B_new= pCatch_planet.arm_b;
                }

                float sucker_y_span = float.Parse(this.sucker_y_span);//193

                //如果超出范围，左移一个分区

                double max = -193;
                for(var i=0;i< list_draw.Count; i++)
                {
                    var item= list_draw[i];
                    if (item.dy > max)
                    {
                        max = item.dy;
                    }
                }


                if (max >= 0)
                {
                    for (var i = 0; i < 吸盘分区.Length; i++)
                    {
                        吸盘分区[i] = 1;
                    }
                }

                //保存吸盘状态到变量
                string line = this.read_string(this.key_regions);
                string[] strSplit = line.Split(",");

                if (strSplit.Length == 吸盘分区.Length)
                {
                    for (var i = 0; i < 吸盘分区.Length; i++)
                    {
                        this.save_var(strSplit[i], "", 吸盘分区[i] + "");
                    }
                }
                else
                {
                    MessageBox.Show("吸盘分区个数设置不对，要设置相应的吸盘分区变量 key_regions");
                }


                Task.Run(() =>
                {
                    Thread.Sleep(3000);
                    string line = "";
                    for (var i = 0; i < 吸盘分区.Length; i++)
                    {
                        line+= 吸盘分区[i] + ",";
                    }
                    Main.show_tip(this, "吸盘位置" , line);
                });


                //这个吸盘最多吸
                List<C_Point3D> list_new = Main.生成点云(A_new, direction);
                C_Point3D D = C_Planet_Catch.计算D坐标(pRobot, B_new);

                pData_Catch.list_3D_Point_arm = list_new;// 点云处理(pData_Catch.list_3D_Point_arm);
                this.save_var(this.key_cloud_save, "List<C_Point3D>", list_new);
                this.save_var(this.key_save, "C_Planet_Catch", pData_Catch.planet);


                (C_Result pResult,double len1,double len2) = Main.根据坐标计算6轴角度(space,
                    this, pRobot, pCatch_planet.Group_ID, 
                    A_new, B_new, D, list_new, this.file, this.angle_dif);

                //this.key_save_len1, this.key_save_len2,
                Main.WriteLine(this, " Train.ID=" + pTrain.get_ID() + " 保存抓取面=" + this.key_save + "===" + pData_Catch.planet.center.ToString());
                
                {
                    bool bRecord = false;
                    C_Planet_Catch pLast = (C_Planet_Catch)this.read_var(this.key_last, "C_Planet_Catch");
                    if (pLast!=null)
                    {
                        if (pData_Catch.planet.arm_a.z < pLast.arm_a.z + 50)
                        {
                            bRecord = true;
                        }
                    }
                    else
                    {
                        bRecord = true;
                    }
                    if (bRecord)
                    {
                        this.save_var(this.key_last, "C_Planet_Catch", pData_Catch.planet);
                    }
                    this.Next_Step = Node_Next.True;
                }
            }
        }

        public Dictionary<string, string> get_regions_from_list(List<C_Cup> list_sucker)
        {
            Dictionary<string, string> regions = new Dictionary<string, string>();
            for (var i = 0; i < list_sucker.Count; i++)
            {
                C_Cup item = list_sucker[i];
           
                if (regions.ContainsKey(item.region) == false)
                    regions.Add(item.region, item.region);
            }
            return regions;
        }


        public Dictionary<string, string> get_regions_from_list_list(List<List<C_Cup>> list_no_sucker)
        {
            Dictionary<string,string> regions = new Dictionary<string, string>();
            for(var i=0;i<list_no_sucker.Count;i++)
            {
                List<C_Cup> list2 = list_no_sucker[i];
                for(var j = 0; j < list2.Count; j++)
                {
                    C_Cup item = list2[j];

                    if (regions.ContainsKey(item.region) ==false)
                        regions.Add(item.region,item.region);
                }
            }
            return regions;
        }

        public bool check_finished(List<C_Space> spaces)
        {
            for (var i = 0; i < spaces.Count; i++)
            {
                var space2 = spaces[i];
                if (space2 != null && space2.finished == false)
                {
                    return false;
                }
            }
            return true;
        }

        public void init()
        {
        }
    }
}
